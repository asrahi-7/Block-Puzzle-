<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Harmony</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on touch devices while dragging */
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .grid-cell {
            aspect-ratio: 1 / 1;
            transition: background-color 0.1s ease-out;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.3);
        }
        .block-piece {
            aspect-ratio: 1 / 1;
            transition: all 0.1s ease-out;
            transform-origin: center;
        }
        .ui-panel {
            background: rgba(30, 41, 59, 0.4);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .dragging {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            transform: scale(1.2);
            opacity: 0.9;
            filter: drop-shadow(0 10px 15px rgba(0,0,0,0.5));
            transition: transform 0.1s ease, opacity 0.1s ease;
        }
        .modal-backdrop {
            background-color: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
        }
        .clearing {
            animation: clear-animation 0.4s ease-out forwards;
        }
        @keyframes clear-animation {
            0% { transform: scale(1) rotate(0); opacity: 1; }
            100% { transform: scale(0) rotate(90deg); opacity: 0; }
        }
        .score-updated {
            animation: score-pop 0.4s ease-out;
        }
        @keyframes score-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.25); color: #67e8f9; }
            100% { transform: scale(1); }
        }
        .ghost {
             background-color: rgba(255, 255, 255, 0.15);
        }
        .ghost-invalid {
            background-color: rgba(239, 68, 68, 0.2);
        }
    </style>
</head>
<body class="text-white flex flex-col items-center justify-center min-h-screen p-2 md:p-4">

    <div class="w-full max-w-lg mx-auto text-center">
        <h1 class="text-4xl md:text-5xl font-bold text-cyan-400 mb-2 tracking-tighter">Block Harmony</h1>
        <p class="text-slate-400 mb-4">Fit the blocks, clear the lines, find your zen.</p>

        <div class="grid grid-cols-2 gap-4 ui-panel rounded-lg p-3 mb-4">
            <div class="text-left">
                <span class="text-slate-400 text-sm font-semibold">SCORE</span>
                <div id="score" class="text-3xl font-bold">0</div>
            </div>
             <div class="text-right">
                <span class="text-slate-400 text-sm font-semibold">BEST</span>
                <div id="high-score" class="text-3xl font-bold">0</div>
            </div>
        </div>

        <!-- Game Grid -->
        <div id="game-grid" class="grid grid-cols-10 gap-1 bg-slate-800/80 p-2 rounded-lg shadow-2xl mb-6 border border-slate-700">
            <!-- Grid cells will be generated by JS -->
        </div>

        <!-- Available Blocks -->
        <div id="blocks-container" class="grid grid-cols-3 gap-4 h-32 md:h-40 items-center justify-center px-4">
             <!-- Block holders will be generated by JS -->
        </div>
        
        <div class="mt-4 flex justify-center items-center gap-4">
             <button id="restart-button" class="ui-panel hover:bg-red-500/50 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">
                Restart
            </button>
             <button id="help-button" class="ui-panel hover:bg-cyan-500/50 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">
                How to Play
            </button>
        </div>
    </div>
    
    <!-- Dragging Clone -->
    <div id="dragging-clone" class="hidden"></div>
    
    <!-- Modals -->
    <div id="instructions-modal" class="fixed inset-0 flex items-center justify-center p-4 modal-backdrop hidden z-50">
        <div class="ui-panel rounded-xl shadow-2xl p-6 md:p-8 w-full max-w-md text-center border-2 border-cyan-400">
            <h2 class="text-3xl font-bold text-cyan-400 mb-4">How to Play</h2>
            <div class="text-slate-300 space-y-4 text-left">
                <p><strong>1. Drag & Drop:</strong> Select one of the three blocks at the bottom and drag it onto the grid.</p>
                <p><strong>2. Complete Lines:</strong> Fill a complete row or column to clear it from the grid and score points.</p>
                <p><strong>3. Plan Ahead:</strong> You get three new blocks only after you've used the current three.</p>
                <p><strong>4. Game Over:</strong> The game ends when you can't place any of the available blocks on the grid.</p>
            </div>
            <button id="close-instructions" class="mt-8 bg-cyan-500 hover:bg-cyan-600 text-slate-900 font-bold py-3 px-6 rounded-lg w-full transition-colors">Got It!</button>
        </div>
    </div>
    
    <div id="game-over-modal" class="fixed inset-0 flex items-center justify-center p-4 modal-backdrop hidden z-50">
        <div class="ui-panel rounded-xl shadow-2xl p-8 md:p-10 w-full max-w-md text-center border-2 border-red-500">
            <h2 class="text-4xl font-bold text-red-500 mb-2">Game Over</h2>
            <p class="text-slate-400 mb-4">No more valid moves!</p>
            <div class="text-lg mb-6">
                <span class="text-slate-300">Final Score:</span>
                <span id="final-score" class="text-3xl font-bold text-white">0</span>
            </div>
            <button id="play-again" class="bg-cyan-500 hover:bg-cyan-600 text-slate-900 font-bold py-3 px-6 rounded-lg w-full transition-colors">Play Again</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const GRID_SIZE = 10;
            const gameGrid = document.getElementById('game-grid');
            const blocksContainer = document.getElementById('blocks-container');
            const scoreDisplay = document.getElementById('score');
            const highScoreDisplay = document.getElementById('high-score');
            
            // Modals & Buttons
            const instructionsModal = document.getElementById('instructions-modal');
            const gameOverModal = document.getElementById('game-over-modal');
            const helpButton = document.getElementById('help-button');
            const closeInstructionsButton = document.getElementById('close-instructions');
            const playAgainButton = document.getElementById('play-again');
            const restartButton = document.getElementById('restart-button');
            const finalScoreDisplay = document.getElementById('final-score');
            
            const draggingClone = document.getElementById('dragging-clone');

            let gridState = [];
            let currentScore = 0;
            let highScore = 0;
            let availableBlocks = [];

            // Dragging State
            let isDragging = false;
            let draggedBlock = null;
            let dragOffset = { x: 0, y: 0 };
            let lastGhost = { cells: [], row: -1, col: -1, isValid: false };

            const BLOCK_SHAPES = {
                i2: { shape: [[1], [1]], color: 'bg-cyan-500', class:'w-1/5'},
                i3: { shape: [[1], [1], [1]], color: 'bg-cyan-500', class:'w-1/5'},
                i4: { shape: [[1], [1], [1], [1]], color: 'bg-cyan-500', class:'w-1/5'},
                i2h: { shape: [[1, 1]], color: 'bg-cyan-500', class:'w-2/5'},
                i3h: { shape: [[1, 1, 1]], color: 'bg-cyan-500', class:'w-3/5'},
                i4h: { shape: [[1, 1, 1, 1]], color: 'bg-cyan-500', class:'w-4/5'},
                o1: { shape: [[1]], color: 'bg-yellow-400', class:'w-1/5'},
                o4: { shape: [[1, 1], [1, 1]], color: 'bg-yellow-400', class:'w-2/5'},
                l: { shape: [[1, 0], [1, 0], [1, 1]], color: 'bg-orange-500', class:'w-2/5'},
                l_r: { shape: [[0, 1], [0, 1], [1, 1]], color: 'bg-orange-500', class:'w-2/5'},
                l_90: { shape: [[1, 1, 1], [1, 0, 0]], color: 'bg-orange-500', class:'w-3/5'},
                t: { shape: [[1, 1, 1], [0, 1, 0]], color: 'bg-purple-500', class:'w-3/5'},
                s: { shape: [[0, 1, 1], [1, 1, 0]], color: 'bg-green-500', class:'w-3/5'},
                z: { shape: [[1, 1, 0], [0, 1, 1]], color: 'bg-red-500', class:'w-3/5'},
            };
            const BLOCK_KEYS = Object.keys(BLOCK_SHAPES);

            function init() {
                // Create Grid
                gameGrid.innerHTML = '';
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell', 'bg-slate-700/50', 'rounded-sm');
                    cell.dataset.row = Math.floor(i / GRID_SIZE);
                    cell.dataset.col = i % GRID_SIZE;
                    gameGrid.appendChild(cell);
                }
                
                // Init State
                gridState = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(null));
                currentScore = 0;
                highScore = localStorage.getItem('blockHarmonyHighScore') || 0;
                updateScore(0, true);
                highScoreDisplay.textContent = highScore;
                
                generateNewBlocks();
                checkGameOver();
            }
            
            function createBlockElement(blockData) {
                const container = document.createElement('div');
                container.classList.add('relative', 'flex', 'items-center', 'justify-center', 'cursor-grab', 'active:cursor-grabbing', blockData.class, 'transition-transform', 'hover:scale-110');
                container.dataset.blockId = blockData.id;
                
                const grid = document.createElement('div');
                grid.style.display = 'grid';
                grid.style.gridTemplateRows = `repeat(${blockData.shape.length}, 1fr)`;
                grid.style.gridTemplateColumns = `repeat(${blockData.shape[0].length}, 1fr)`;
                grid.style.gap = '4px';
                grid.classList.add('w-full');

                for (let r = 0; r < blockData.shape.length; r++) {
                    for (let c = 0; c < blockData.shape[0].length; c++) {
                        const piece = document.createElement('div');
                        if (blockData.shape[r][c] === 1) {
                            piece.classList.add('block-piece', blockData.color, 'rounded-sm', 'shadow-lg');
                        }
                        grid.appendChild(piece);
                    }
                }
                container.appendChild(grid);
                return container;
            }

            function generateNewBlocks() {
                blocksContainer.innerHTML = '';
                availableBlocks = [];
                for (let i = 0; i < 3; i++) {
                    const blockKey = BLOCK_KEYS[Math.floor(Math.random() * BLOCK_KEYS.length)];
                    const blockData = { ...BLOCK_SHAPES[blockKey], id: blockKey + '_' + i };
                    availableBlocks.push(blockData);
                    
                    const blockHolder = document.createElement('div');
                    blockHolder.classList.add('flex', 'items-center', 'justify-center', 'w-full', 'h-full', 'p-2');
                    
                    const blockEl = createBlockElement(blockData);
                    
                    blockHolder.appendChild(blockEl);
                    blocksContainer.appendChild(blockHolder);
                }
            }
            
            function canPlaceBlock(block, startRow, startCol) {
                for (let r = 0; r < block.shape.length; r++) {
                    for (let c = 0; c < block.shape[0].length; c++) {
                        if (block.shape[r][c] === 1) {
                            const gridRow = startRow + r;
                            const gridCol = startCol + c;
                            if (gridRow >= GRID_SIZE || gridCol >= GRID_SIZE || gridRow < 0 || gridCol < 0 || gridState[gridRow][gridCol]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            function placeBlock(block, startRow, startCol) {
                let points = 0;
                for (let r = 0; r < block.shape.length; r++) {
                    for (let c = 0; c < block.shape[0].length; c++) {
                        if (block.shape[r][c] === 1) {
                            gridState[startRow + r][startCol + c] = block.color;
                            points++;
                        }
                    }
                }
                updateScore(points);
            }
            
            function checkAndClearLines() {
                let linesToClear = { rows: [], cols: [] };

                for (let r = 0; r < GRID_SIZE; r++) {
                    if (gridState[r].every(cell => cell !== null)) linesToClear.rows.push(r);
                }
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (gridState.every(row => row[c] !== null)) linesToClear.cols.push(c);
                }
                
                if (linesToClear.rows.length > 0 || linesToClear.cols.length > 0) {
                    clearLines(linesToClear);
                } else {
                    renderGrid();
                }
            }
            
            function clearLines(lines) {
                const clearedCount = lines.rows.length + lines.cols.length;
                const bonus = clearedCount * 10 * clearedCount;
                updateScore(bonus);

                const cellsToClear = new Set();
                lines.rows.forEach(r => {
                    for(let c=0; c<GRID_SIZE; c++) cellsToClear.add(r * GRID_SIZE + c);
                });
                lines.cols.forEach(c => {
                    for(let r=0; r<GRID_SIZE; r++) cellsToClear.add(r * GRID_SIZE + c);
                });

                cellsToClear.forEach(cellIndex => {
                    gameGrid.children[cellIndex].firstChild?.classList.add('clearing');
                });

                setTimeout(() => {
                    lines.rows.forEach(r => {
                        for (let c = 0; c < GRID_SIZE; c++) gridState[r][c] = null;
                    });
                    lines.cols.forEach(c => {
                        for (let r = 0; r < GRID_SIZE; r++) gridState[r][c] = null;
                    });
                    renderGrid();
                }, 400);
            }

            function renderGrid() {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cellIndex = r * GRID_SIZE + c;
                        const cell = gameGrid.children[cellIndex];
                        cell.innerHTML = '';
                        if (gridState[r][c]) {
                            const piece = document.createElement('div');
                            piece.className = `block-piece w-full h-full ${gridState[r][c]} rounded-sm shadow-md`;
                            cell.appendChild(piece);
                        }
                    }
                }
            }

            function updateScore(points, isReset = false) {
                if (isReset) {
                    currentScore = 0;
                } else {
                    currentScore += points;
                }
                scoreDisplay.textContent = currentScore;
                if (points > 0) {
                    scoreDisplay.classList.add('score-updated');
                    scoreDisplay.addEventListener('animationend', () => {
                        scoreDisplay.classList.remove('score-updated');
                    }, { once: true });
                }
            }
            
            function checkGameOver() {
                const hasMoves = availableBlocks.some(block => {
                    if (!block) return false;
                    for (let r = 0; r <= GRID_SIZE - block.shape.length; r++) {
                        for (let c = 0; c <= GRID_SIZE - block.shape[0].length; c++) {
                            if (canPlaceBlock(block, r, c)) return true;
                        }
                    }
                    return false;
                });

                if (!hasMoves) gameOver();
            }
            
            function gameOver() {
                if(currentScore > highScore) {
                    highScore = currentScore;
                    localStorage.setItem('blockHarmonyHighScore', highScore);
                    highScoreDisplay.textContent = highScore;
                }
                finalScoreDisplay.textContent = currentScore;
                gameOverModal.classList.remove('hidden');
            }

            // --- New Drag and Drop Logic ---
            function startDrag(e, blockEl) {
                if(!blockEl || !blockEl.dataset.blockId || isDragging) return;
                
                const blockId = blockEl.dataset.blockId;
                const block = availableBlocks.find(b => b && b.id === blockId);
                if (!block) return;

                isDragging = true;
                draggedBlock = block;
                
                const rect = blockEl.getBoundingClientRect();
                const pointer = e.touches ? e.touches[0] : e;
                dragOffset.x = pointer.clientX - rect.left;
                dragOffset.y = pointer.clientY - rect.top;
                
                draggingClone.innerHTML = blockEl.innerHTML;
                draggingClone.className = '';
                draggingClone.classList.add('dragging', 'flex', 'items-center', 'justify-center', draggedBlock.class);
                draggingClone.style.width = `${rect.width}px`;
                draggingClone.style.height = `${rect.height}px`;
                
                updateClonePosition(pointer);
                draggingClone.classList.remove('hidden');
                
                blockEl.parentElement.classList.add('opacity-30');
            }
            
            function onDrag(e) {
                if (!isDragging || !draggedBlock) return;
                e.preventDefault(); // Prevents touch scrolling
                const pointer = e.touches ? e.touches[0] : e;
                updateClonePosition(pointer);
                updateGhost(pointer);
            }
            
            function endDrag() {
                if (!isDragging || !draggedBlock) return;
                
                clearGhost();

                if (lastGhost.isValid) {
                    placeBlock(draggedBlock, lastGhost.row, lastGhost.col);
                    
                    const blockIndex = availableBlocks.findIndex(b => b && b.id === draggedBlock.id);
                    if (blockIndex !== -1) availableBlocks[blockIndex] = null;
                    
                    const originalBlockEl = document.querySelector(`[data-block-id="${draggedBlock.id}"]`);
                    if(originalBlockEl) originalBlockEl.parentElement.innerHTML = '';
                    
                    checkAndClearLines();

                    if (availableBlocks.every(b => b === null)) {
                        generateNewBlocks();
                    }
                    checkGameOver();
                }

                // Reset dragging state
                draggedBlock = null;
                isDragging = false;
                draggingClone.classList.add('hidden');
                lastGhost = { cells: [], row: -1, col: -1, isValid: false };
                
                blocksContainer.querySelectorAll('.opacity-30').forEach(el => el.classList.remove('opacity-30'));
            }

            function updateClonePosition(pointer) {
                draggingClone.style.left = `${pointer.clientX - dragOffset.x}px`;
                draggingClone.style.top = `${pointer.clientY - dragOffset.y}px`;
            }

            function updateGhost(pointer) {
                clearGhost();

                const gridRect = gameGrid.getBoundingClientRect();
                const cellWidth = gridRect.width / GRID_SIZE;
                
                const relativeX = pointer.clientX - gridRect.left - dragOffset.x;
                const relativeY = pointer.clientY - gridRect.top - dragOffset.y;
                
                const targetCol = Math.round(relativeX / cellWidth);
                const targetRow = Math.round(relativeY / cellWidth);
                
                lastGhost.row = targetRow;
                lastGhost.col = targetCol;
                lastGhost.isValid = canPlaceBlock(draggedBlock, targetRow, targetCol);
                
                for (let r = 0; r < draggedBlock.shape.length; r++) {
                    for (let c = 0; c < draggedBlock.shape[0].length; c++) {
                        if (draggedBlock.shape[r][c] === 1) {
                            const gridRow = targetRow + r;
                            const gridCol = targetCol + c;
                            if (gridRow < GRID_SIZE && gridCol < GRID_SIZE && gridRow >= 0 && gridCol >= 0) {
                                const cellIndex = gridRow * GRID_SIZE + gridCol;
                                const cell = gameGrid.children[cellIndex];
                                if(cell) {
                                    cell.classList.add(lastGhost.isValid ? 'ghost' : 'ghost-invalid');
                                    lastGhost.cells.push(cell);
                                }
                            }
                        }
                    }
                }
            }

            function clearGhost() {
                lastGhost.cells.forEach(cell => {
                    cell.classList.remove('ghost', 'ghost-invalid');
                });
                lastGhost.cells = [];
            }
            

            // --- Event Listeners ---
            blocksContainer.addEventListener('mousedown', e => {
                startDrag(e, e.target.closest('[data-block-id]'));
            });
            blocksContainer.addEventListener('touchstart', e => {
                startDrag(e, e.target.closest('[data-block-id]'));
            });

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });

            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);

            // Modal & Controls listeners
            helpButton.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
            closeInstructionsButton.addEventListener('click', () => instructionsModal.classList.add('hidden'));
            
            function restartGame() {
                gameOverModal.classList.add('hidden');
                init();
            }

            playAgainButton.addEventListener('click', restartGame);
            restartButton.addEventListener('click', restartGame);

            init();
        });
    </script>
</body>
</html>
