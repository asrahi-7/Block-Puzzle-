<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Harmony</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on touch devices while dragging */
        }
        .grid-cell {
            aspect-ratio: 1 / 1;
        }
        .block-piece {
            aspect-ratio: 1 / 1;
            transition: all 0.1s ease-out;
        }
        .dragging {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            transform: scale(1.2);
            opacity: 0.8;
        }
        .modal-backdrop {
            background-color: rgba(0,0,0,0.7);
        }
        .clearing {
            animation: clear-animation 0.4s ease-out forwards;
        }
        @keyframes clear-animation {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex flex-col items-center justify-center min-h-screen p-4 overflow-hidden">

    <div class="w-full max-w-lg mx-auto text-center">
        <h1 class="text-4xl md:text-5xl font-bold text-cyan-400 mb-2">Block Harmony</h1>
        <p class="text-slate-400 mb-4">Fit the blocks, clear the lines, find your zen.</p>

        <div class="flex justify-between items-center bg-slate-800 rounded-lg p-3 mb-4">
            <div class="text-left">
                <span class="text-slate-400 text-sm">SCORE</span>
                <div id="score" class="text-2xl font-bold">0</div>
            </div>
            <div class="text-right">
                 <button id="help-button" class="bg-slate-700 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    How to Play
                </button>
            </div>
        </div>

        <!-- Game Grid -->
        <div id="game-grid" class="grid grid-cols-10 gap-1 bg-slate-800 p-2 rounded-lg shadow-2xl mb-6">
            <!-- Grid cells will be generated by JS -->
        </div>

        <!-- Available Blocks -->
        <div id="blocks-container" class="grid grid-cols-3 gap-4 h-32 md:h-40 items-center justify-center">
             <!-- Block holders will be generated by JS -->
        </div>
    </div>
    
    <!-- Dragging Clone -->
    <div id="dragging-clone" class="hidden"></div>
    
    <!-- Modals -->
    <div id="instructions-modal" class="fixed inset-0 flex items-center justify-center p-4 modal-backdrop hidden z-50">
        <div class="bg-slate-800 rounded-xl shadow-2xl p-6 md:p-8 w-full max-w-md text-center border-2 border-cyan-400">
            <h2 class="text-3xl font-bold text-cyan-400 mb-4">How to Play</h2>
            <div class="text-slate-300 space-y-4 text-left">
                <p><strong>1. Drag & Drop:</strong> Select one of the three blocks at the bottom and drag it onto the grid.</p>
                <p><strong>2. Complete Lines:</strong> Fill a complete row or column to clear it from the grid and score points.</p>
                <p><strong>3. Plan Ahead:</strong> You get three new blocks only after you've used the current three.</p>
                <p><strong>4. Game Over:</strong> The game ends when you can't place any of the available blocks on the grid.</p>
            </div>
            <button id="close-instructions" class="mt-8 bg-cyan-500 hover:bg-cyan-600 text-slate-900 font-bold py-3 px-6 rounded-lg w-full transition-colors">Got It!</button>
        </div>
    </div>
    
    <div id="game-over-modal" class="fixed inset-0 flex items-center justify-center p-4 modal-backdrop hidden z-50">
        <div class="bg-slate-800 rounded-xl shadow-2xl p-8 md:p-10 w-full max-w-md text-center border-2 border-red-500">
            <h2 class="text-4xl font-bold text-red-500 mb-2">Game Over</h2>
            <p class="text-slate-400 mb-4">No more moves!</p>
            <div class="text-lg mb-6">
                <span class="text-slate-300">Final Score:</span>
                <span id="final-score" class="text-3xl font-bold text-white">0</span>
            </div>
            <button id="play-again" class="bg-cyan-500 hover:bg-cyan-600 text-slate-900 font-bold py-3 px-6 rounded-lg w-full transition-colors">Play Again</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const GRID_SIZE = 10;
            const gameGrid = document.getElementById('game-grid');
            const blocksContainer = document.getElementById('blocks-container');
            const scoreDisplay = document.getElementById('score');
            
            // Modals
            const instructionsModal = document.getElementById('instructions-modal');
            const gameOverModal = document.getElementById('game-over-modal');
            const helpButton = document.getElementById('help-button');
            const closeInstructionsButton = document.getElementById('close-instructions');
            const playAgainButton = document.getElementById('play-again');
            const finalScoreDisplay = document.getElementById('final-score');
            
            // Dragging elements
            const draggingClone = document.getElementById('dragging-clone');

            let gridState = [];
            let currentScore = 0;
            let availableBlocks = [];
            let isDragging = false;
            let draggedBlock = null;
            let dragOffset = { x: 0, y: 0 };
            let currentPointer = { x: 0, y: 0 };

            // Block Definitions
            const BLOCK_SHAPES = {
                // I
                i2: { shape: [[1], [1]], color: 'bg-cyan-500', class:'w-1/5'},
                i3: { shape: [[1], [1], [1]], color: 'bg-cyan-500', class:'w-1/5'},
                i4: { shape: [[1], [1], [1], [1]], color: 'bg-cyan-500', class:'w-1/5'},
                i2h: { shape: [[1, 1]], color: 'bg-cyan-500', class:'w-2/5'},
                i3h: { shape: [[1, 1, 1]], color: 'bg-cyan-500', class:'w-3/5'},
                i4h: { shape: [[1, 1, 1, 1]], color: 'bg-cyan-500', class:'w-4/5'},
                // O
                o1: { shape: [[1]], color: 'bg-yellow-400', class:'w-1/5'},
                o4: { shape: [[1, 1], [1, 1]], color: 'bg-yellow-400', class:'w-2/5'},
                // L
                l: { shape: [[1, 0], [1, 0], [1, 1]], color: 'bg-orange-500', class:'w-2/5'},
                l_r: { shape: [[0, 1], [0, 1], [1, 1]], color: 'bg-orange-500', class:'w-2/5'},
                l_90: { shape: [[1, 1, 1], [1, 0, 0]], color: 'bg-orange-500', class:'w-3/5'},
                l_180: { shape: [[1, 1], [0, 1], [0, 1]], color: 'bg-orange-500', class:'w-2/5'},
                // T
                t: { shape: [[1, 1, 1], [0, 1, 0]], color: 'bg-purple-500', class:'w-3/5'},
                t_90: { shape: [[1, 0], [1, 1], [1, 0]], color: 'bg-purple-500', class:'w-2/5'},
                // S
                s: { shape: [[0, 1, 1], [1, 1, 0]], color: 'bg-green-500', class:'w-3/5'},
                s_90: { shape: [[1, 0], [1, 1], [0, 1]], color: 'bg-green-500', class:'w-2/5'},
                // Z
                z: { shape: [[1, 1, 0], [0, 1, 1]], color: 'bg-red-500', class:'w-3/5'},
                z_90: { shape: [[0, 1], [1, 1], [1, 0]], color: 'bg-red-500', class:'w-2/5'},
            };
            const BLOCK_KEYS = Object.keys(BLOCK_SHAPES);

            function init() {
                // Create Grid
                gameGrid.innerHTML = '';
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell', 'bg-slate-700', 'rounded-sm');
                    cell.dataset.row = Math.floor(i / GRID_SIZE);
                    cell.dataset.col = i % GRID_SIZE;
                    gameGrid.appendChild(cell);
                }
                
                // Init State
                gridState = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(null));
                currentScore = 0;
                updateScore();
                
                generateNewBlocks();
                checkGameOver();
            }
            
            function createBlockElement(blockData) {
                const container = document.createElement('div');
                container.classList.add('relative', 'flex', 'items-center', 'justify-center', 'cursor-grab', 'active:cursor-grabbing', blockData.class);
                container.dataset.blockId = blockData.id;
                
                const grid = document.createElement('div');
                grid.style.display = 'grid';
                grid.style.gridTemplateRows = `repeat(${blockData.shape.length}, 1fr)`;
                grid.style.gridTemplateColumns = `repeat(${blockData.shape[0].length}, 1fr)`;
                grid.style.gap = '4px';
                grid.classList.add('w-full');

                for (let r = 0; r < blockData.shape.length; r++) {
                    for (let c = 0; c < blockData.shape[0].length; c++) {
                        const piece = document.createElement('div');
                        if (blockData.shape[r][c] === 1) {
                            piece.classList.add('block-piece', blockData.color, 'rounded-sm');
                        }
                        grid.appendChild(piece);
                    }
                }
                container.appendChild(grid);
                return container;
            }

            function generateNewBlocks() {
                blocksContainer.innerHTML = '';
                availableBlocks = [];
                for (let i = 0; i < 3; i++) {
                    const blockKey = BLOCK_KEYS[Math.floor(Math.random() * BLOCK_KEYS.length)];
                    const blockData = { ...BLOCK_SHAPES[blockKey], id: blockKey + '_' + i };
                    availableBlocks.push(blockData);
                    
                    const blockHolder = document.createElement('div');
                    blockHolder.classList.add('flex', 'items-center', 'justify-center', 'w-full', 'h-full', 'p-2');
                    
                    const blockEl = createBlockElement(blockData);
                    
                    blockHolder.appendChild(blockEl);
                    blocksContainer.appendChild(blockHolder);
                }
            }
            
            function canPlaceBlock(block, startRow, startCol) {
                for (let r = 0; r < block.shape.length; r++) {
                    for (let c = 0; c < block.shape[0].length; c++) {
                        if (block.shape[r][c] === 1) {
                            const gridRow = startRow + r;
                            const gridCol = startCol + c;
                            if (gridRow >= GRID_SIZE || gridCol >= GRID_SIZE || gridRow < 0 || gridCol < 0 || gridState[gridRow][gridCol]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            function placeBlock(block, startRow, startCol) {
                let points = 0;
                for (let r = 0; r < block.shape.length; r++) {
                    for (let c = 0; c < block.shape[0].length; c++) {
                        if (block.shape[r][c] === 1) {
                            const gridRow = startRow + r;
                            const gridCol = startCol + c;
                            gridState[gridRow][gridCol] = block.color;
                            points++;
                        }
                    }
                }
                currentScore += points;
            }
            
            function checkAndClearLines() {
                let linesToClear = { rows: [], cols: [] };

                // Check rows
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (gridState[r].every(cell => cell !== null)) {
                        linesToClear.rows.push(r);
                    }
                }
                // Check columns
                for (let c = 0; c < GRID_SIZE; c++) {
                    let colFull = true;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        if (gridState[r][c] === null) {
                            colFull = false;
                            break;
                        }
                    }
                    if (colFull) {
                        linesToClear.cols.push(c);
                    }
                }
                
                if (linesToClear.rows.length > 0 || linesToClear.cols.length > 0) {
                    clearLines(linesToClear);
                } else {
                    renderGrid();
                }
            }
            
            function clearLines(lines) {
                 const clearedCount = lines.rows.length + lines.cols.length;
                 currentScore += clearedCount * 10 * clearedCount; // Bonus for multi-line clears

                 lines.rows.forEach(r => {
                     for(let c=0; c<GRID_SIZE; c++) {
                        const cellIndex = r * GRID_SIZE + c;
                        gameGrid.children[cellIndex].firstChild?.classList.add('clearing');
                     }
                 });
                 lines.cols.forEach(c => {
                     for(let r=0; r<GRID_SIZE; r++) {
                        const cellIndex = r * GRID_SIZE + c;
                        gameGrid.children[cellIndex].firstChild?.classList.add('clearing');
                     }
                 });

                 setTimeout(() => {
                    lines.rows.forEach(r => {
                        for (let c = 0; c < GRID_SIZE; c++) gridState[r][c] = null;
                    });
                    lines.cols.forEach(c => {
                        for (let r = 0; r < GRID_SIZE; r++) gridState[r][c] = null;
                    });
                    renderGrid();
                    updateScore();
                }, 400);
            }

            function renderGrid() {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cellIndex = r * GRID_SIZE + c;
                        const cell = gameGrid.children[cellIndex];
                        cell.innerHTML = '';
                        if (gridState[r][c]) {
                            const piece = document.createElement('div');
                            piece.className = `block-piece w-full h-full ${gridState[r][c]} rounded-sm`;
                            cell.appendChild(piece);
                        }
                    }
                }
            }

            function updateScore() {
                scoreDisplay.textContent = currentScore;
            }
            
            function checkGameOver() {
                for (const block of availableBlocks) {
                    if(!block) continue;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (canPlaceBlock(block, r, c)) {
                                return; // Found a possible move
                            }
                        }
                    }
                }
                // No moves for any available block
                gameOver();
            }
            
            function gameOver() {
                finalScoreDisplay.textContent = currentScore;
                gameOverModal.classList.remove('hidden');
            }

            // --- Drag and Drop Logic ---
            function startDrag(e, blockEl) {
                if(!blockEl.dataset.blockId) return;
                isDragging = true;
                
                const blockId = blockEl.dataset.blockId;
                draggedBlock = availableBlocks.find(b => b.id === blockId);
                if (!draggedBlock) return;

                const rect = blockEl.getBoundingClientRect();
                const pointer = e.touches ? e.touches[0] : e;
                dragOffset.x = pointer.clientX - rect.left;
                dragOffset.y = pointer.clientY - rect.top;
                
                // Create visual clone for dragging
                draggingClone.innerHTML = blockEl.innerHTML;
                draggingClone.className = '';
                draggingClone.classList.add('dragging', 'flex', 'items-center', 'justify-center', draggedBlock.class);
                draggingClone.style.width = `${rect.width}px`;
                draggingClone.style.height = `${rect.height}px`;
                
                updateClonePosition(pointer);
                draggingClone.classList.remove('hidden');
                
                blockEl.parentElement.classList.add('opacity-30'); // Hide original
            }
            
            function onDrag(e) {
                if (!isDragging || !draggedBlock) return;
                const pointer = e.touches ? e.touches[0] : e;
                currentPointer = {x: pointer.clientX, y: pointer.clientY};
                updateClonePosition(pointer);
            }
            
            function updateClonePosition(pointer) {
                 draggingClone.style.left = `${pointer.clientX - dragOffset.x}px`;
                 draggingClone.style.top = `${pointer.clientY - dragOffset.y}px`;
            }

            function endDrag() {
                if (!isDragging || !draggedBlock) return;
                
                const gridRect = gameGrid.getBoundingClientRect();
                
                if (currentPointer.x > gridRect.left && currentPointer.x < gridRect.right &&
                    currentPointer.y > gridRect.top && currentPointer.y < gridRect.bottom) {
                    
                    const cellWidth = gridRect.width / GRID_SIZE;
                    const cellHeight = gridRect.height / GRID_SIZE;

                    // Adjust for the shape's own dimensions to find the top-left corner
                    const shapeWidthInCells = draggedBlock.shape[0].length;
                    const shapeHeightInCells = draggedBlock.shape.length;

                    // Calculate the position of the top-left cell of the shape on the grid
                    const relativeX = currentPointer.x - gridRect.left - (dragOffset.x / draggingClone.getBoundingClientRect().width * shapeWidthInCells * cellWidth);
                    const relativeY = currentPointer.y - gridRect.top - (dragOffset.y / draggingClone.getBoundingClientRect().height * shapeHeightInCells * cellHeight);

                    const targetCol = Math.round(relativeX / cellWidth);
                    const targetRow = Math.round(relativeY / cellHeight);

                    if (canPlaceBlock(draggedBlock, targetRow, targetCol)) {
                        placeBlock(draggedBlock, targetRow, targetCol);
                        
                        const blockIndex = availableBlocks.findIndex(b => b && b.id === draggedBlock.id);
                        availableBlocks[blockIndex] = null;
                        
                        // Remove from UI
                        const originalBlockEl = document.querySelector(`[data-block-id="${draggedBlock.id}"]`);
                        if(originalBlockEl) originalBlockEl.parentElement.innerHTML = '';
                        
                        checkAndClearLines();
                        updateScore();

                        if (availableBlocks.every(b => b === null)) {
                            generateNewBlocks();
                        }
                        checkGameOver();
                    }
                }
                
                // Reset dragging state
                draggedBlock = null;
                isDragging = false;
                draggingClone.classList.add('hidden');
                
                // Unhide original blocks that were not placed
                blocksContainer.querySelectorAll('.opacity-30').forEach(el => el.classList.remove('opacity-30'));
            }

            // --- Event Listeners ---
            blocksContainer.addEventListener('mousedown', e => {
                const blockEl = e.target.closest('[data-block-id]');
                if (blockEl) startDrag(e, blockEl);
            });
            blocksContainer.addEventListener('touchstart', e => {
                const blockEl = e.target.closest('[data-block-id]');
                if (blockEl) startDrag(e, blockEl);
            });

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag);

            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);

            // Modal listeners
            helpButton.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
            closeInstructionsButton.addEventListener('click', () => instructionsModal.classList.add('hidden'));
            
            playAgainButton.addEventListener('click', () => {
                gameOverModal.classList.add('hidden');
                init();
            });

            // Start game
            init();
        });
    </script>
</body>
</html>
